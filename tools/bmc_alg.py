import os
import subprocess
import sys
import glob
import shutil as _shutil
  

# =================================================================
# CONFIGURATION
# =================================================================
# Use 'gtime' on macOS (brew install gnu-time) or '/usr/bin/time' on Linux.

TIME_BIN = os.environ.get("TIME_BIN") or ("gtime" if (sys.platform=="darwin" and _shutil.which("gtime")) else "/usr/bin/time")
SMT_REACH_BIN = os.environ.get("SMT_REACH_BIN") or ("smtreach4tis" if _shutil.which("smtreach4tis") else "/Users/azbrzez1/PycharmProjects/flask_bmc4tis/tools/smtreach4tis")
Z3_BIN = "z3"

def parse_time_log(log_file):
    """
    Parses the log file generated by gtime/time.
    Format: "%M %U %S" -> Max Memory (KB), User Time, System Time
    """    
    try:
        with open(log_file, 'r') as f:
            parts = f.read().strip().split()
            if len(parts) >= 3:
                return float(parts[0]), float(parts[1]) + float(parts[2])
    except: pass
    return 0.0, 0.0

def run_bmc_iteration(k, net_file, efo_file):
    """
    Runs a single BMC iteration: SMT generation and SMT solving.
    """
    print(net_file)
    base_name = os.path.splitext(net_file)[0]
    expected_smt_file = f"{base_name}-k{k}.smt"
    
    reach_log = "tmp_reach.log"
    z3_log = "tmp_z3.log"


    reach_cmd = [TIME_BIN, "-o", reach_log, "-f", "%M %U %S", SMT_REACH_BIN, net_file, efo_file, str(k)]
    print(f"  [k={k}] Generating SMT formula...", end=" ", flush=True)
    out_path = f"{base_name}-bmc-k{k}.out"
    with open(out_path, "w", encoding="utf-8") as f:
        subprocess.run(reach_cmd, stdout=f, stderr=subprocess.PIPE, text=True, check=False)

    print(f'{reach_cmd}')
            
    if not os.path.exists(expected_smt_file) or os.path.getsize(expected_smt_file) == 0:
        return "error", 0, 0, 0, 0

    m_reach, t_reach = parse_time_log(reach_log)

    z3_cmd = [TIME_BIN, "-o", z3_log, "-f", "%M %U %S", Z3_BIN, expected_smt_file]
    print("Running Z3 solver...", end=" ", flush=True)
    
    z3_out = f"{base_name}-k{k}.out"

    with open(z3_out, "w") as out_f:
        subprocess.run(z3_cmd, stdout=out_f, stderr=subprocess.DEVNULL)
    
    print("tu dupa")
    m_z3, t_z3 = parse_time_log(z3_log)
    
    
    prefix = os.path.splitext(net_file)[0]
    attack = os.path.splitext(efo_file)[0].removeprefix(prefix)[1:]
    
    result = "unknown"
    with open(z3_out, "r") as f:
        content = f.read().lower()
        if "unsat" in content:
            result = "unsat"
        elif "sat" in content: 
            result = "sat"
            wit_out = f"{prefix}-{attack}-tis-k{k}.wit"
            with open(wit_out, "w", encoding="utf-8") as f:
                subprocess.run(
                    ["python3", "/Users/azbrzez1/PycharmProjects/flask_bmc4tis/tools/gen_wit_z3.py", z3_out],
                    stdout=f,
                    stderr=subprocess.PIPE,   # albo subprocess.STDOUT jeśli też chcesz do .wit
                    text=True,
                    check=False
                )


    for lck_file in glob.glob("*.lck"):
        try:
            os.remove(lck_file)
        except OSError:
            pass 
    
   
    for f in [expected_smt_file, reach_log, z3_log, z3_out,out_path]:
        if os.path.exists(f): 
            os.remove(f)


    return result, t_reach, m_reach, t_z3, m_z3

def bmc_algorithm(net_file, efo_file, n_steps):
    """
    Standard iterative BMC algorithm with a completeness threshold.
    """
    
    max_k = 4 * n_steps
    prefix = os.path.splitext(net_file)[0]
    attack = os.path.splitext(efo_file)[0].removeprefix(prefix)[1:]
    
    # Nazwy trzech plików .dat
    dat_reach = f"{prefix}_{attack}_tis_bmc.dat"
    dat_z3 = f"{prefix}_{attack}_tis_z3.dat"
    dat_total = f"{prefix}_{attack}_tis_total.dat"

    # Inicjalizacja nagłówków
    header = "# k | time(s) | mem(KB)\n"
    for f_path in [dat_reach, dat_z3, dat_total]:
        with open(f_path, "w") as f: f.write(header)

    k = 0
    while k <= max_k:
        res, t_r, m_r, t_z, m_z = run_bmc_iteration(k, net_file, efo_file)
        
        if res == "error":
            print("Błąd generatora SMT.")
            break

        with open(dat_reach, "a") as f: f.write(f"{k} {t_r:.2f} {m_r}\n")
        with open(dat_z3, "a") as f: f.write(f"{k} {t_z:.2f} {m_z}\n")
        
       
        t_total = t_r + t_z
        m_total = max(m_r, m_z) 
        with open(dat_total, "a") as f: f.write(f"{k} {t_total:.2f} {m_total}\n")
        
        print(f"Result: {res.upper()}")
        if res == "sat":
            print(f"\n[!] REACHABLE at k={k}")
            return
        elif res == "unknown":
            print(f"\n[?] UNKNOWN at k={k}")
            return "UNKNOWN"
            
        k += 2

    print(f"\n[+] UNREACHABLE (Threshold k={max_k} reached)")

if __name__ == "__main__":
    if len(sys.argv) < 4:
        print("Usage: python bmc_alg.py <model.tis> <property.efo> <n_protocol_steps>")   
    else:    
        bmc_algorithm(sys.argv[1][:-4], sys.argv[2][:-4], int(sys.argv[3]))
